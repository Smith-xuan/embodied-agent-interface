{
    "Background": "# Background\nYou are determining complete state transitions of a household task solving by a robot. The goal is to list all intermediate states and necessary actions in temporal order to achieve the target goals. The output consists of Boolean expressions, which are comprised of state and action primitives. Here, a state or action primitive is a first-order predicate as combinition of a predicate name and its parameters. Please note that do not use actions in your output unless necessary.\n",
    "StateInfo": "# Primitive Format Introduction\n## State Primitive\nState primitive is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. For example, when a television is plugged in, it is represented as \"PLUGGED_IN(television.1). Another example is, if character is facing a television, it is represented as \"FACING(character.1, television.1)\". Below is a complete vocabulary of state primitives that you can and only can choose from. Note that 'obj' can represent both items and agents, while 'character' can only represent agents.\n\n| Predicate Name | Arguments | Description |\n| --- | --- | --- |\n| CLOSED | (obj1.id) | obj1 is closed |\n| OPEN | (obj1.id) | obj1 is open |\n| ON | (obj1.id) | obj1 is turned on, or it is activated |\n| OFF | (obj1.id) | obj1 is turned off, or it is deactivated |\n| PLUGGED_IN | (obj1.id) | obj1 is plugged in |\n| PLUGGED_OUT | (obj1.id) | obj1 is unplugged |\n| SITTING | (character1.id) | character1 is sitting, and this represents a state of a character |\n| LYING | (character1.id) | character1 is lying |\n| CLEAN | (obj1.id) | obj1 is clean |\n| DIRTY | (obj1.id) | obj1 is dirty |\n| ONTOP | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| INSIDE | (obj1.id, obj2.id) | obj1 is inside obj2 |\n| BETWEEN | (obj1.id, obj2.id, obj3.id) | obj1 is between obj2 and obj3 |\n| NEXT_TO | (obj1.id, obj2.id) | obj1 is close to or next to obj2 |\n| FACING | (character1.id, obj1.id) | character1 is facing obj1 |\n| HOLDS_RH | (character1.id, obj1.id) | character1 is holding obj1 with right hand |\n| HOLDS_LH | (character1.id, obj1.id) | character1 is holding obj1 with left hand |\n",
    "ActionInfo": "## Action Primitive\nAction primitive is similar to state primitive. Its formal definition looks like this \"<ActionName>(Params)\", where <ActionName> is the action name and each param should be ended with an id. Note that, you do not need to list actions in most cases. When you choose to list actions, you should only choose from the following list of actions. For other cases, use state predicate as substitutes. Here, 'obj' only refers to items, not agents.\n\n| Action Name | Arguments | Argument Restriction | Description |\n| --- | --- | --- | --- |\n| DRINK | (obj1.id) | obj1 is ['DRINKABLE', 'RECIPIENT'] | drinks obj1, need to hold obj1 first |\n| EAT | (obj1.id) | obj1 is ['EATABLE'] | eats obj1, need to hold obj1 first |\n| CUT | (obj1.id) | obj1 is ['EATABLE', 'CUTABLE'] | cuts obj1, obj1 is food|\n| TOUCH | (obj1.id) | none | touches obj1 |\n| LOOKAT | (obj1.id) | none | looks at obj1, it has a precondition that agent should be facing at obj1 first |\n| WATCH | (obj1.id) | none | watches obj1 |\n| READ | (obj1.id) | obj1 is ['READABLE'] | reads obj1, need to hold obj1 first |\n| TYPE | (obj1.id) | obj1 is ['HAS_SWITCH'] | types on obj1 |\n| PUSH | (obj1.id) | obj1 is ['MOVABLE'] | pushes obj1 |\n| PULL | (obj1.id) | obj1 is ['MOVABLE'] | pulls obj1 |\n| MOVE | (obj1.id) | obj1 is ['MOVABLE'] | moves obj1 |\n| SQUEEZE | (obj1.id) | obj1 is ['CLOTHES'] | squeezes obj1 |\n| SLEEP | none | none | sleeps, need to be at LYING or SITTING first |\n| WAKEUP | none | none | wakes up, need to be at LYING or SITTING first |\n| RINSE | (obj1.id) | none | rinses obj1, use only for cleaning appliances or teeth |\n| SCRUB | (obj1.id) | none | scrubs obj1, use only for cleaning appliances or teeth |\n| WASH | (obj1.id) | none | washes obj1, use only for appliances |\n| GRAB | (obj1.id) | obj1 is ['GRABBABLE'] | grabs obj1 |\n| SWITCHOFF | (obj1.id) | obj1 is ['HAS_SWITCH'] | switches off obj1 |\n",
    "SupplementInfo": "## Temporal Logic Formula Grammar\n- Temporal logic formula refers to a Boolean expression that describes a subgoals plan with temporal and logical order.\n- The atomic Boolean expression includes both state primitive and action primitive.\n- Boolean expressions in the same line are interchangeable with no temporal order requirement.\n- Boolean expresssions in different lines are in temporal order, where the first one should be satisfied before the second one.\n- Boolean expression can be combined with the following logical operators: \"not\", \"and\", \"or\".\n- The \"not\" operator negates the following Boolean expression.\n- The \"and\" operator combines Boolean expressions that are interchangeable but needs to be satisfied simultaneously in the end.\n- The \"or\" operator combines Boolean expressions that are interchangeable but only one of them needs to be satisfied in the end.\n- When there is temporal order requirement, output the Boolean expressions in different lines.\n- You must use and only use actions required in the input information.",
    "GoldExamples": [
        "# Example 1: Task category is \"Listen to music\"\n## Relelvant objects in this scene\n| obj | category | properties |\n| --- | --- | --- |\n| bathroom.1 | Rooms | [] |\n| character.65 | Characters | [] |\n| home_office.319 | Rooms | [] |\n| couch.352 | Furniture | ['LIEABLE', 'MOVABLE', 'SITTABLE', 'SURFACES'] |     \n| television.410 | Electronics | ['HAS_PLUG', 'HAS_SWITCH', 'LOOKABLE'] |      \n| dvd_player.1000 | placable_objects | ['CAN_OPEN', 'GRABBABLE', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'SURFACES'] |\n\n## Initial States\nCLEAN(dvd_player.1000)\nCLOSED(dvd_player.1000)\nOFF(dvd_player.1000)\nPLUGGED_IN(dvd_player.1000)\nINSIDE(character.65, bathroom.1)\n\n## Final Goal\n[States]: After subgoals are executed, the following state primitives must be satisfied. Add intermediate states if necessary to improve logical consistency. If you want to change state of A, while A is in B and B is closed, you should open B first.\nCLOSED(dvd_player.1000)\nON(dvd_player.1000)\nPLUGGED_IN(dvd_player.1000)\n[Actions]: The following actions must be included in the subgoals plan, each line is one action to satisfy. If \"A or B or ...\" is presented in one line, then only one of them needs to be satisfied.\nNone\n\n## Necessity to use actions\nNo\n\n## Output: Based on initial states, achieve final goal states and/or actions logically and reasonably one by one.\nNEXT_TO(character.65, dvd_player.1000)\nFACING(character.65, dvd_player.1000)\nPLUGGED_IN(dvd_player.1000) and CLOSED(dvd_player.1000)\nON(dvd_player.1000)\n",
        "# Example 2: Task category is \"Wash Hands\"\n## Relelvant objects in this scene\n| bathroom.1 | Rooms | [] |\n| bathroom_counter.41 | Furniture | ['SURFACES'] |\n| sink.42 | Furniture | ['CONTAINERS', 'RECIPIENT'] |\n| faucet.43 | Furniture | ['HAS_SWITCH'] |\n| character.65 | Characters | [] |\n| home_office.319 | Rooms | [] |\n| hands_both.1000 | placable_objects | ['BODY_PART'] |\n\n## Initial States\nINSIDE(character.65, home_office.319)\n\n## Final Goal\n[States]: After subgoals are executed, the following state primitives must be satisfied. Add intermediate states if necessary to improve logical consistency. If you want to change state of A, while A is in B and B is closed, you should open B first.\nNone\n[Actions]: The following actions must be included in the subgoals plan, each line is one action to satisfy. If \"A or B or ...\" is presented in one line, then only one of them needs to be satisfied.\nRINSE or WASH\n\n## Necessity to use actions\nYes\n\n## Output: Based on initial states, achieve final goal states and/or actions logically and reasonably one by one.\nNEXT_TO(character.65, sink.42)\nON(faucet.43)\nRINSE(hands_both.1000)\nOFF(faucet.43)\n",
        "# Example 3: Task category is \"Browse internet\"\n## Relelvant objects in this scene\n| bathroom.1 | Rooms | [] |\n| character.65 | Characters | [] |\n| floor.208 | Floor | ['SURFACES'] |\n| wall.213 | Walls | [] |\n| home_office.319 | Rooms | [] |\n| floor.325 | Floors | ['SURFACES'] |\n| floor.326 | Floors | ['SURFACES'] |\n| wall.330 | Walls | [] |\n| wall.331 | Walls | [] |\n| doorjamb.346 | Doors | [] |\n| walllamp.351 | Lamps | [] |\n| chair.356 | Furniture | ['GRABBABLE', 'MOVABLE', 'SITTABLE', 'SURFACES'] |   \n| desk.357 | Furniture | ['MOVABLE', 'SURFACES'] |\n| powersocket.412 | Electronics | [] |\n| mouse.413 | Electronics | ['GRABBABLE', 'HAS_PLUG', 'MOVABLE'] |\n| mousepad.414 | Electronics | ['MOVABLE', 'SURFACES'] |\n| keyboard.415 | Electronics | ['GRABBABLE', 'HAS_PLUG', 'MOVABLE'] |\n| cpuscreen.416 | Electronics | [] |\n| computer.417 | Electronics | ['HAS_SWITCH', 'LOOKABLE'] |\n\n## Initial States\nCLEAN(computer.417)\nOFF(computer.417)\nONTOP(mouse.413, mousepad.414)\nONTOP(mouse.413, desk.357)\nONTOP(keyboard.415, desk.357)\nINSIDE(character.65, bathroom.1)\n\n## Final Goal\n[States]: After subgoals are executed, the following state primitives must be satisfied. Add intermediate states if necessary to improve logical consistency. If you want to change state of A, while A is in B and B is closed, you should open B first.\nON(computer.417)\nINSIDE(character.65, home_office.319)\nHOLDS_LH(character.65, keyboard.415)\nFACING(character.65, computer.417)\nHOLDS_RH(character.65, mouse.413)\n[Actions]: The following actions must be included in the subgoals plan, each line is one action to satisfy. If \"A or B or ...\" is presented in one line, then only one of them needs to be satisfied.\nLOOKAT or WATCH\n\n## Necessity to use actions\nYes\n\n## Output: Based on initial states, achieve final goal states and/or actions logically and reasonably one by one.\nNEXT_TO(character.65, computer.417)\nONTOP(character.65, chair.356)\nHOLDS_RH(character.65, mouse.413) and HOLDS_LH(character.65, keyboard.415)\nFACING(character.65, computer.417)\nLOOKAT(computer.417)\n"
    ],
    "TaskInfo": "\n# Target Task: Task category is <task_name>\n## Relevant objects in this scene\n<relevant_objects>\n\n## Initial States\n<initial_states>\n\n## Final Goal\n[States]: After subgoals are executed, the following state primitives must be satisfied. Add intermediate states if necessary to improve logical consistency. If you want to change state of A, while A is in B and B is closed, you should open B first.\n<final_states>\n[Actions]: The following actions must be included in the subgoals plan, each line is one action to satisfy. If \"A or B or ...\" is presented in one line, then only one of them needs to be satisfied. Do not include any actions not listed here in your output.\n<final_actions>\n\n## Necessity to use actions\n<necessity>\n\n## Output: Based on initial states, achieve final goal states and/or actions logically and reasonably one by one.\n"
}
{
    "Background": "# Background\nYou are determining the complete state transitions of a household task solving by a robot. The goal is to list all intermediate states and necessary action instructions to achieve the final state. The output consists of states and instructions, where states are represented in first-order predicate and instructions are represented as a combanition of an action and its parameters. The states or instructions in your output must be ordered, consistent and logical. Please note that do not incorporate the instructions into the output unless necessary.\n",
    "StateInfo": "# Data Format Introduction\n## State Introduction\nThe state is represented as a first-order predicate, which is a tuple of a predicate name and its arguments. Its formal definition looks like this \"<PredicateName>(Params)\", where <PredicateName> is the state name and each param should be ended with an id. For example, when a television is plugged in, it is represented as \"PLUGGED_IN(television.1). Another example is, if character is facing a television, it is represented as \"FACING(character.1, television.1)\". Below is a complete list of predicates that you may choose and only choose from. Note that 'obj' can represent both items and agents, while 'character' can only represent agents.\n\n| Predicate Name | Arguments | Description |\n| --- | --- | --- |\n| CLOSED | (obj1.id) | obj1 is closed |\n| OPEN | (obj1.id) | obj1 is open |\n| ON | (obj1.id) | obj1 is turned on, or it is activated |\n| OFF | (obj1.id) | obj1 is turned off, or it is deactivated |\n| PLUGGED_IN | (obj1.id) | obj1 is plugged in |\n| PLUGGED_OUT | (obj1.id) | obj1 is unplugged |\n| SITTING | (character1.id) | character1 is sitting, and this represents a state of a character |\n| LYING | (character1.id) | character1 is lying |\n| CLEAN | (obj1.id) | obj1 is clean |\n| DIRTY | (obj1.id) | obj1 is dirty |\n| ONTOP | (obj1.id, obj2.id) | obj1 is on top of obj2 |\n| INSIDE | (obj1.id, obj2.id) | obj1 is inside obj2 |\n| BETWEEN | (obj1.id, obj2.id, obj3.id) | obj1 is between obj2 and obj3 |\n| NEXT_TO | (obj1.id, obj2.id) | obj1 is close to or next to obj2 |\n| FACING | (character1.id, obj1.id) | character1 is facing obj1 |\n| HOLDS_RH | (character1.id, obj1.id) | character1 is holding obj1 with right hand |\n| HOLDS_LH | (character1.id, obj1.id) | character1 is holding obj1 with left hand |\n\n",
    "ActionInfo": "## Action Instruciton Introduction\nAn instruction describes an action and its parameters. It is represented as a tuple of an action and its parameters. Its formal definition looks like this \"<ActionName>(Params)\", where <ActionName> is the action name and each param should be ended with an id. For example, when an agent will watch TV, a valid instruction to this is \"LOOKAT(television.1)\" or \"WATCH(television.1)\".\nNote that, you do not need to list actions in most cases. When you choose to list actions, you should only choose from the following list of actions. For other cases, use state predicate as substitutes. Here, 'obj' only refers to items, not agents.\n\n| Action Name | Arguments | Argument Restriction | Description |\n| --- | --- | --- | --- |\n| DRINK | (obj1.id) | obj1 is ['DRINKABLE', 'RECIPIENT'] | drinks obj1, need to hold obj1 first |\n| EAT | (obj1.id) | obj1 is ['EATABLE'] | eats obj1, need to hold obj1 first |\n| CUT | (obj1.id) | obj1 is ['EATABLE', 'CUTABLE'] | cuts obj1, obj1 is food|\n| TOUCH | (obj1.id) | none | touches obj1 |\n| LOOKAT | (obj1.id) | none | looks at obj1, it has a precondition that agent should be facing at obj1 first |\n| WATCH | (obj1.id) | none | watches obj1 |\n| READ | (obj1.id) | obj1 is ['READABLE'] | reads obj1, need to hold obj1 first |\n| TYPE | (obj1.id) | obj1 is ['HAS_SWITCH'] | types on obj1 |\n| PUSH | (obj1.id) | obj1 is ['MOVABLE'] | pushes obj1 |\n| PULL | (obj1.id) | obj1 is ['MOVABLE'] | pulls obj1 |\n| MOVE | (obj1.id) | obj1 is ['MOVABLE'] | moves obj1 |\n| SQUEEZE | (obj1.id) | obj1 is ['CLOTHES'] | squeezes obj1 |\n| SLEEP | none | none | sleeps, need to be at LYING or SITTING first |\n| WAKEUP | none | none | wakes up, need to be at LYING or SITTING first |\n| RINSE | (obj1.id) | none | rinses obj1, use only for cleaning appliances or teeth |\n| SCRUB | (obj1.id) | none | scrubs obj1, use only for cleaning appliances or teeth |\n| WASH | (obj1.id) | none | washes obj1, use only for appliances |\n| GRAB | (obj1.id) | obj1 is ['GRABBABLE'] | grabs obj1 |\n| SWITCHOFF | (obj1.id) | obj1 is ['HAS_SWITCH'] | switches off obj1 |\n",
    "SupplementInfo": "## Supplement Information\n- All predicate names in states and action instructions should be upper case.\n- The output states should be ordered, consistent and logical.\n- In our current scenerio, the robot is the only agent in the environment. So please use \"character\" as agent name. Plus, agent is never a valid argument in action instructions.\n- Only output important intermediate states and necessary action instructions. For every two adjacent states A and B, please make sure that A can transition to B within two action instructions.\n- When you want to denote a relation that a character is sitting on something, you should use \"ONTOP(character.1, obj.1)\" instead of \"SITTING(character.1)\" and if you want to say the character is now sitting, you should use \"SITTING(character.1)\", where \"character.1\" and \"obj.1\" should be replaced.\n- When making your output, do not include irrelevant information.\n",
    "GoldExamples": [
        "# Example 1: Task category is \"Listen to music\"\n## Relelvant objects in this scene\n| obj | category | properties |\n| --- | --- | --- |\n| bathroom.1 | Rooms | [] |\n| character.65 | Characters | [] |\n| home_office.319 | Rooms | [] |\n| couch.352 | Furniture | ['LIEABLE', 'MOVABLE', 'SITTABLE', 'SURFACES'] |     \n| television.410 | Electronics | ['HAS_PLUG', 'HAS_SWITCH', 'LOOKABLE'] |      \n| dvd_player.1000 | placable_objects | ['CAN_OPEN', 'GRABBABLE', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'SURFACES'] |\n\n## Initial States\nCLEAN(dvd_player.1000)\nCLOSED(dvd_player.1000)\nOFF(dvd_player.1000)\nPLUGGED_IN(dvd_player.1000)\nINSIDE(character.65, bathroom.1)\n\n## Final Goal\n[States]: The final states presented below are not well ordered. Therefore, find the correct order to achieve them one by one. Add intermediate states if necessary to improve logical consistency. If you want to change state of A, while A is in B and B is closed, you should open B first.\nCLOSED(dvd_player.1000)\nON(dvd_player.1000)\nPLUGGED_IN(dvd_player.1000)\n[Actions Must Include]: Actions are listed in the execution order, each line is one action to satisfy. If \"A or B or ...\" is presented in one line, then only one of them needs to be satisfied.\nNone\n\n## Necessity to use actions\nNo\n\n## Output: Based on initial states, achieve final goal states and/or actions logically and reasonably one by one.\nNEXT_TO(character.65, dvd_player.1000)\nFACING(character.65, dvd_player.1000)\nPLUGGED_IN(dvd_player.1000)\nCLOSED(dvd_player.1000)\nON(dvd_player.1000)\n",
        "# Example 2: Task category is \"Wash Hands\"\n## Relelvant objects in this scene\n| bathroom.1 | Rooms | [] |\n| bathroom_counter.41 | Furniture | ['SURFACES'] |\n| sink.42 | Furniture | ['CONTAINERS', 'RECIPIENT'] |\n| faucet.43 | Furniture | ['HAS_SWITCH'] |\n| character.65 | Characters | [] |\n| home_office.319 | Rooms | [] |\n| hands_both.1000 | placable_objects | ['BODY_PART'] |\n\n## Initial States\nINSIDE(character.65, home_office.319)\n\n## Final Goal\n[States]: The final states presented below are not well ordered. Therefore, find the correct order to achieve them one by one. Add intermediate states if necessary to improve logical consistency. If you want to change state of A, while A is in B and B is closed, you should open B first.\nNone\n[Actions Must Include]: Actions are listed in the execution order, each line is one action to satisfy. If \"A or B or ...\" is presented in one line, then only one of them needs to be satisfied.\nRINSE or WASH\n\n## Necessity to use actions\nYes\n\n## Output: Based on initial states, achieve final goal states and/or actions logically and reasonably one by one.\nNEXT_TO(character.65, sink.42)\nON(faucet.43)\nRINSE(hands_both.1000)\nOFF(faucet.43)\n",
        "# Example 3: Task category is \"Browse internet\"\n## Relelvant objects in this scene\n| bathroom.1 | Rooms | [] |\n| character.65 | Characters | [] |\n| floor.208 | Floor | ['SURFACES'] |\n| wall.213 | Walls | [] |\n| home_office.319 | Rooms | [] |\n| floor.325 | Floors | ['SURFACES'] |\n| floor.326 | Floors | ['SURFACES'] |\n| wall.330 | Walls | [] |\n| wall.331 | Walls | [] |\n| doorjamb.346 | Doors | [] |\n| walllamp.351 | Lamps | [] |\n| chair.356 | Furniture | ['GRABBABLE', 'MOVABLE', 'SITTABLE', 'SURFACES'] |   \n| desk.357 | Furniture | ['MOVABLE', 'SURFACES'] |\n| powersocket.412 | Electronics | [] |\n| mouse.413 | Electronics | ['GRABBABLE', 'HAS_PLUG', 'MOVABLE'] |\n| mousepad.414 | Electronics | ['MOVABLE', 'SURFACES'] |\n| keyboard.415 | Electronics | ['GRABBABLE', 'HAS_PLUG', 'MOVABLE'] |\n| cpuscreen.416 | Electronics | [] |\n| computer.417 | Electronics | ['HAS_SWITCH', 'LOOKABLE'] |\n\n## Initial States\nCLEAN(computer.417)\nOFF(computer.417)\nONTOP(mouse.413, mousepad.414)\nONTOP(mouse.413, desk.357)\nONTOP(keyboard.415, desk.357)\nINSIDE(character.65, bathroom.1)\n\n## Final Goal\n[States]: The final states presented below are not well ordered. Therefore, find the correct order to achieve them one by one. Add intermediate states if necessary to improve logical consistency. If you want to change state of A, while A is in B and B is closed, you should open B first.\nON(computer.417)\nINSIDE(character.65, home_office.319)\nHOLDS_LH(character.65, keyboard.415)\nFACING(character.65, computer.417)\nHOLDS_RH(character.65, mouse.413)\n[Actions Must Include]: Actions are listed in the execution order, each line is one action to satisfy. If \"A or B or ...\" is presented in one line, then only one of them needs to be satisfied.\nLOOKAT or WATCH\n\n## Necessity to use actions\nYes\n\n## Output: Based on initial states, achieve final goal states and/or actions logically and reasonably one by one.\nNEXT_TO(character.65, computer.417)\nONTOP(character.65, chair.356)\nHOLDS_RH(character.65, mouse.413)\nHOLDS_LH(character.65, keyboard.415)\nFACING(character.65, computer.417)\nLOOKAT(computer.417)\n"
    ],
    "AnswerFormat": "",
    "TaskInfo": "\n# Target Task: Task category is <task_name>\n## Relevant objects in this scene\n<relevant_objects>\n\n## Initial States\n<initial_states>\n\n## Final Goal\n[States]: The final states presented below are not well ordered. Therefore, find the correct order to achieve them one by one. Add intermediate states if necessary to improve logical consistency. If you want to change state of A, while A is in B and B is closed, you should open B first.\n<final_states>\n[Actions Must Include]: Actions are listed in the execution order, each line is one action to satisfy. If \"A or B or ...\" is presented in one line, then only one of them needs to be satisfied. You should only use actions presented here.\n<final_actions>\n\n## Necessity to use actions\n<necessity>\n\n## Output: Based on initial states, achieve final goal states and/or actions logically and reasonably one by one.\n"
}
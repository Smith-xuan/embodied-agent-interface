You are designing instructions for a household robot. The goal is to guide the robot to take actions from current state to fulfill some node goals and edge goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals and edge goals. The output should be a list of action commands so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. 

Data format:
Objects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)

Nodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. 
Nodes follow the format: object_name, states:... , properties:...
Edges follow the format: object_name A is ... to object_name B

 

Node goals is a list indicating the desired ending states of objects. Each goal in the list is a dictionary with two keys 'name' and 'state'. The value of 'name' is the name of target object, and the value of 'state' is the desired ending state of the target object. For example, [{'name': 'washing_machine', 'state': 'PLUGGED_IN'}, {'name': 'washing_machine', 'state': 'CLOSED'}, {'name': 'washing_machine', 'state': 'ON'}] requires the washing_machine in the ending environment to be PLUGGED_IN, CLOSED, and ON. A node goal is satisfied if the object in the ending environment has the same state as the goal.

Edge goals is a list indicating the desired ending states of edges. Each goal in the list is a dictionary with three keys 'from_name', and 'relation' and 'to_name'. The value of 'relation' is desired relationship between 'from_name' object to 'to_name' object. The value of 'from_name' and 'to_name' is either an object name, or a wildcard of some objects. Wildcard starts and ends with ?. Wildcard is represented by the properties the objects should have. Each property is wrapped by <>. For example, ?[<Property.GRABBABLE>, <Property.HANGABLE>, <Property.CLOTHES>, <Property.MOVABLE>]? represents any object that have properties GRABBABLE, HANGABLE, CLOTHES, and MOVABLE. So this wildcard can represent any of the clothes_jacket, clothes_pants, clothes_shirt, clothes_dress, clothes_underwear, because these objects have the aforementioned 4 properties. A edge goal is satisfied if the ending environment has a same edge as the goal. 



Action commands have three types of format, please strictly follow the output format. 1)[action_name] 2) [action_name] <object_name> (object_id) 3) [action_name] <object_name1> (object_id1) <object_name2> (object_id2). Each action_name has a pre-defined number (0, 1, or 2) of objects to be applied. The object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = ("Switch on", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = ("Pour", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).

The rule's format is: action_name = (humanized name: str, required_number of parameters: int, preconditions for each objects: List[List[str]]). Here is the complete list of ALL supported actions. 

CLOSE = ("Close", 1, [['CAN_OPEN']]) # as opposed to open sth, CLOSE sth means changing the state from OPEN to CLOSE, not get close to!
DRINK = ("Drink", 1, [['DRINKABLE', 'RECIPIENT']]) # drink up sth
FIND = ("Find", 1, [[]]) # find and get near to sth
WALK = ("Walk", 1, [[]]) # walk towards sth, get near to sth
GRAB = ("Grab", 1, [['GRABBABLE']]) # graph sth
LOOKAT = ("Look at", 1, [[]]) # look at sth, face sth
LOOKAT_SHORT = ("Look at short", 1, [[]]) # shortly look at sth
LOOKAT_MEDIUM = LOOKAT
LOOKAT_LONG = ("Look at long", 1, [[]]) # look at sth for long
OPEN = ("Open", 1, [['CAN_OPEN']]) # open sth, as opposed to close sth
POINTAT = ("Point at", 1, [[]]) # point at sth
PUTBACK = ("Put", 2, [['GRABBABLE'], []]) # put object A back to object B
PUTIN = ("Put in", 2, [['GRABBABLE'], ['CAN_OPEN']]) # put object A into object B
PUTOBJBACK = ("Put back", 1, [[]]) # put object back to its original place
RUN = ("Run", 1, [[]]) # run towards sth, get close to sth
SIT = ("Sit", 1, [['SITTABLE']]) # sit on sth
STANDUP = ("Stand up", 0) # stand up
SWITCHOFF = ("Switch off", 1, [['HAS_SWITCH']] ) # switch sth off (normally lamp/light)
SWITCHON = ("Switch on", 1, [['HAS_SWITCH']]) # switch sth on (normally lamp/light)
TOUCH = ("Touch", 1, [[]]) # touch sth
TURNTO = ("Turn to", 1, [[]]) # turn and face sth
WATCH = ("Watch", 1, [[]]) # watch sth
WIPE = ("Wipe", 1, [[]]) # wipe sth out
PUTON = ("PutOn", 1, [['CLOTHES']]) # put on clothes, need to hold the clothes first
PUTOFF = ("PutOff", 1, [['CLOHES']]) # put off clothes
GREET = ("Greet", 1, [['PERSON']]) # greet to somebody
DROP = ("Drop", 1, [[]]) # drop something in robot's current room, need to hold the thing first
READ = ("Read", 1, [['READABLE']]) # read something, need to hold the thing first
LIE = ("Lie", 1, [['LIEABLE']]) # lie on something, need to get close the thing first
POUR = ("Pour", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # pour object A into object B
TYPE = ("Type", 1, [['HAS_SWITCH']]) # type on keyboard
PUSH = ("Push", 1, [['MOVABLE']]) # move sth
PULL = ("Pull", 1, [['MOVABLE']]) # move sth
MOVE = ("Move", 1, [['MOVABLE']]) # move sth
WASH = ("Wash", 1, [[]]) # wash sth
RINSE = ("Rinse", 1, [[]]) # rinse sth
SCRUB = ("Scrub", 1, [[]]) # scrub sth
SQUEEZE = ("Squeeze", 1, [['CLOTHES']]) # squeeze the clothes
PLUGIN = ("PlugIn", 1, [['HAS_PLUG']]) # plug in the plug
PLUGOUT = ("PlugOut", 1, [['HAS_PLUG']]) # plug out the plug
CUT = ("Cut", 1, [['EATABLE', 'CUTABLE']]) # cut some food
EAT = ("Eat", 1, [['EATABLE']]) # eat some food
RELEASE = ("Release", 1, [[]]) # drop sth inside the current room

Notice: CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. If you want <character> NEAR to some object, you should apply FIND OR WALK action as [FIND] <object_name> or [WALK] <object_name>, where the target object is the only argument.

Notice: The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. 

Notice: You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.

The action_name should be upper case, the object_name is "class_name" in "nodes" sub-dictionaries and the object_id is "id" in "nodes" sub-dictionaries. An action should strictly follow one of the given formats depending on the predefined number of objects: 1)[action_name] 2) [action_name] <object_name> (object_id) 3) [action_name] <object_name1> (object_id1) <object_name2> (object_id2). Keep the brackets, parenthesis and angle brackets.

Input:
<object_in_scene>

Current environment state:
<cur_change>

Node goals:
<node_goals>

Edge goals:
<edge_goals>

Please output the list of action commands (in the given format) so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals and edge goals. Only output the list of action commands with nothing else.

Output:
[
    {
        "identifier": "11_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "120_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "125_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "150_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "160_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncontroller, id: 1000, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nlight, id: 1002, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncontroller, id: 1001, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "180_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "205_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "222_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "232_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 1001, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "310_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "311_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "331_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "339_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "345_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nhome_office, id: 319, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nfiling_cabinet, id: 399, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<remote_control> (1000) is ON to <filing_cabinet> (399)\n<remote_control> (1000) is NEAR to <filing_cabinet> (399)\n<filing_cabinet> (399) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "392_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nlight, id: 64, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "394_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "432_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "443_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "445_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "511_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "585_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\nfloor_lamp, id: 1001, properties: ['HAS_SWITCH', 'MOVABLE']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "604_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nlight, id: 64, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "616_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nlight, id: 64, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "627_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "705_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "708_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "715_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\nlight, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "737_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "780_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nlight, id: 1000, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "812_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "835_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nfloor_lamp is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "85_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "874_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nbedroom, id: 67, properties: []\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nlight is ON\nlight is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1003_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nwalllamp, id: 351, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<keyboard> (415) is ON to <desk> (357)\n<mouse> (413) is NEAR to <powersocket> (412)\n<keyboard> (415) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n<keyboard> (415) is NEAR to <wall> (330)\n<character> (65) is INSIDE to <bedroom> (67)\n<mouse> (413) is NEAR to <mousepad> (414)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<floor> (208) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <walllamp> (351)\n<mouse> (413) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <mousepad> (414)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<floor> (326) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <floor> (208)\n<keyboard> (415) is NEAR to <computer> (417)\n<wall> (331) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <floor> (326)\n<cpuscreen> (416) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <chair> (356)\n<walllamp> (351) is NEAR to <keyboard> (415)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<keyboard> (415) is NEAR to <desk> (357)\n<computer> (417) is NEAR to <keyboard> (415)\n<wall> (213) is NEAR to <keyboard> (415)\n<floor> (325) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <floor> (325)\n<floor> (326) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (331)\n<floor> (325) is NEAR to <keyboard> (415)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mousepad> (414) is NEAR to <keyboard> (415)\n<desk> (357) is NEAR to <keyboard> (415)\n<powersocket> (412) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <wall> (213)\n<wall> (331) is NEAR to <keyboard> (415)\n<wall> (330) is NEAR to <keyboard> (415)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <chair> (356)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\nSWITCHOFF\nSWITCHOFF\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "115_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "407_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\naddress_book, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "430_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "481_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nhome_office, id: 319, properties: []\nmail, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'MOVABLE', 'GRABBABLE']\nbutton, id: 1001, properties: ['MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\nSWITCHOFF\nSWITCHOFF\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "622_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\ndining_room, id: 201, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\nmouse, states: ['PLUGGED_OUT', 'CLEAN'], properties:['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nkeyboard, states: ['PLUGGED_OUT', 'CLEAN'], properties:['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "699_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nmail, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'MOVABLE', 'GRABBABLE']\ncheck, id: 1001, properties: ['READABLE', 'HAS_PAPER', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\nmail, states: ['CLEAN', 'CLOSED'], properties:['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<check> (1001) is INSIDE to <mail> (1000)\n<chair> (356) is NEAR to <check> (1001)\n<character> (65) is INSIDE to <dining_room> (201)\n<check> (1001) is NEAR to <chair> (356)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "824_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "87_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nlaptop, id: 1000, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlaptop, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <powersocket> (412)\n<mouse> (413) is NEAR to <wall> (330)\n<laptop> (1000) is NEAR to <mouse> (413)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<mouse> (413) is NEAR to <floor> (208)\n<wall> (331) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <computer> (417)\n<floor> (325) is NEAR to <mouse> (413)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<powersocket> (412) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <laptop> (1000)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\nlaptop is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "986_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\nhair, id: 2012, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\nSWITCHOFF\nSWITCHOFF\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "996_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nchair, id: 1000, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ncomputer, id: 1001, properties: ['LOOKABLE', 'HAS_SWITCH']\nkeyboard, id: 1002, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTYPE\nTYPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1004_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfood_food, id: 1000, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_food is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "152_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfood_food, id: 1000, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_food is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "298_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nfood_food, id: 1000, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_food is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "609_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfood_food, id: 1000, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "703_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfood_food, id: 1000, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_food is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "772_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nmilk, id: 1000, properties: ['CAN_OPEN', 'POURABLE', 'DRINKABLE', 'MOVABLE', 'GRABBABLE']\nfood_turkey, id: 1001, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ndining_room, id: 201, properties: []\nfood_egg, id: 1003, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nfood_egg, id: 1002, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nfood_fish, id: 1005, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nfood_chicken, id: 1006, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nfood_egg, id: 1004, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "837_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\ncolander, id: 2003, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE']\nfood_food, id: 2004, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncoffe_maker, id: 290, properties: ['CAN_OPEN', 'HAS_PLUG', 'CONTAINERS', 'RECIPIENT', 'HAS_SWITCH', 'MOVABLE']\ntoaster, id: 292, properties: ['HAS_SWITCH', 'MOVABLE', 'HAS_PLUG']\nkitchen_counter, id: 230, properties: ['SURFACES']\nfaucet, id: 232, properties: ['HAS_SWITCH']\nfood_cheese, id: 1001, properties: ['EATABLE', 'CUTTABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\nmilk, id: 1002, properties: ['CAN_OPEN', 'POURABLE', 'DRINKABLE', 'MOVABLE', 'GRABBABLE']\nfood_vegetable, id: 1003, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nfood_egg, id: 1004, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nmicrowave, id: 297, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\nfood_food, id: 1000, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<kitchen_counter> (230) is NEAR to <food_vegetable> (1003)\n<kitchen_counter> (230) is NEAR to <food_egg> (1004)\n<kitchen_counter> (230) is NEAR to <milk> (1002)\n<food_vegetable> (1003) is NEAR to <kitchen_counter> (230)\n<character> (65) is INSIDE to <bedroom> (67)\n<kitchen_counter> (230) is NEAR to <food_cheese> (1001)\n<food_cheese> (1001) is NEAR to <kitchen_counter> (230)\n<milk> (1002) is NEAR to <kitchen_counter> (230)\n<food_egg> (1004) is NEAR to <kitchen_counter> (230)\n-----------------\n\n\nNode goals are:\nfreezer is OPEN\nfreezer is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nfood_cheese is INSIDE to freezer\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "323_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntoilet, id: 37, properties: ['SITTABLE', 'CONTAINERS', 'CAN_OPEN']\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntoilet, states: ['CLEAN', 'OFF', 'CLOSED'], properties:['SITTABLE', 'CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is ON to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "430_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntoilet, id: 37, properties: ['SITTABLE', 'CONTAINERS', 'CAN_OPEN']\ntoilet_paper, id: 1000, properties: ['HANGABLE', 'HAS_PAPER', 'CUTTABLE', 'COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nbathroom_counter, id: 41, properties: ['SURFACES']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<toilet> (37) is NEAR to <toilet_paper> (1000)\n<toilet_paper> (1000) is NEAR to <toilet> (37)\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is ON to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "478_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntoilet, id: 37, properties: ['SITTABLE', 'CONTAINERS', 'CAN_OPEN']\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is ON to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "624_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ntoilet, id: 1000, properties: ['SITTABLE', 'CONTAINERS', 'CAN_OPEN']\ncharacter, id: 65, properties: []\ndresser, id: 108, properties: ['CONTAINERS', 'CAN_OPEN']\ntoilet_paper, id: 1001, properties: ['HANGABLE', 'HAS_PAPER', 'CUTTABLE', 'COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<toilet_paper> (1001) is NEAR to <toilet> (1000)\n<toilet> (1000) is NEAR to <toilet_paper> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is ON to toilet\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "101_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1068_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "153_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "196_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\ndining_room, id: 201, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "198_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<character> (65) is INSIDE to <bathroom> (1)\n<mouse> (413) is NEAR to <powersocket> (412)\n<mouse> (413) is NEAR to <wall> (330)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<mouse> (413) is NEAR to <floor> (208)\n<wall> (331) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <computer> (417)\n<floor> (325) is NEAR to <mouse> (413)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<powersocket> (412) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "201_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "232_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "234_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <powersocket> (412)\n<mouse> (413) is NEAR to <wall> (330)\n<wall> (213) is NEAR to <mouse> (413)\n<character> (65) is INSIDE to <bedroom> (67)\n<mouse> (413) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<mouse> (413) is NEAR to <floor> (208)\n<wall> (331) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <computer> (417)\n<floor> (325) is NEAR to <mouse> (413)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<powersocket> (412) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "343_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 75, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 207, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 210, properties: []\nwall, id: 83, properties: []\nwall, id: 84, properties: []\nmouse, id: 166, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 168, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ncomputer, id: 170, properties: ['LOOKABLE', 'HAS_SWITCH']\nbookshelf, id: 233, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\ncpuscreen, id: 171, properties: []\ndesk, id: 104, properties: ['SURFACES', 'MOVABLE']\nmousepad, id: 167, properties: ['SURFACES', 'MOVABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<keyboard> (168) is NEAR to <light> (169)\n<keyboard> (168) is NEAR to <wall> (84)\n<mouse> (166) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <wall> (210)\n<wall> (210) is NEAR to <keyboard> (168)\n<floor> (75) is NEAR to <keyboard> (168)\n<bookshelf> (233) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <computer> (170)\n<keyboard> (168) is NEAR to <bookshelf> (233)\n<chair> (103) is NEAR to <keyboard> (168)\n<floor> (207) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <cpuscreen> (171)\n<keyboard> (168) is NEAR to <chair> (103)\n<keyboard> (168) is NEAR to <desk> (104)\n<mousepad> (167) is NEAR to <keyboard> (168)\n<wall> (209) is NEAR to <keyboard> (168)\n<keyboard> (168) is ON to <desk> (104)\n<keyboard> (168) is NEAR to <wall> (83)\n<desk> (104) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <mouse> (166)\n<floor> (76) is NEAR to <keyboard> (168)\n<wall> (83) is NEAR to <keyboard> (168)\n<cpuscreen> (171) is NEAR to <keyboard> (168)\n<light> (169) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <mousepad> (167)\n<keyboard> (168) is NEAR to <floor> (75)\n<keyboard> (168) is NEAR to <wall> (209)\n<wall> (84) is NEAR to <keyboard> (168)\n<keyboard> (168) is NEAR to <floor> (207)\n<keyboard> (168) is NEAR to <floor> (76)\n<computer> (170) is NEAR to <keyboard> (168)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "373_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "406_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nkeyboard, id: 168, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\ncomputer, id: 170, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "409_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "419_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\nhair, id: 2008, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "433_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nmouse, id: 166, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 168, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncomputer, id: 170, properties: ['LOOKABLE', 'HAS_SWITCH']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "437_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nhair, id: 2014, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<character> (65) is INSIDE to <bathroom> (1)\n<mouse> (413) is NEAR to <powersocket> (412)\n<mouse> (413) is NEAR to <wall> (330)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<mouse> (413) is NEAR to <floor> (208)\n<wall> (331) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <computer> (417)\n<floor> (325) is NEAR to <mouse> (413)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<powersocket> (412) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "440_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nmouse, id: 166, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 167, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 168, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ndesk, id: 104, properties: ['SURFACES', 'MOVABLE']\ncomputer, id: 170, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ncpuscreen, id: 171, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "453_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "46_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <powersocket> (412)\n<mouse> (413) is NEAR to <wall> (330)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<mouse> (413) is NEAR to <floor> (208)\n<wall> (331) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <computer> (417)\n<floor> (325) is NEAR to <mouse> (413)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<powersocket> (412) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "475_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "503_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <powersocket> (412)\n<mouse> (413) is NEAR to <wall> (330)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<mouse> (413) is NEAR to <floor> (208)\n<wall> (331) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <computer> (417)\n<floor> (325) is NEAR to <mouse> (413)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<powersocket> (412) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "670_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nwalllamp, id: 351, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\ncharacter, states: [], properties:[]\ndesk, states: ['CLEAN', 'CLOSED'], properties:['SURFACES', 'MOVABLE']\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nmouse, states: ['PLUGGED_OUT', 'CLEAN'], properties:['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nkeyboard, states: ['PLUGGED_OUT', 'CLEAN'], properties:['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<mouse> (413) is INSIDE to <desk> (357)\n<mouse> (413) is NEAR to <powersocket> (412)\n<keyboard> (415) is NEAR to <cpuscreen> (416)\n<mouse> (413) is NEAR to <wall> (330)\n<keyboard> (415) is NEAR to <wall> (330)\n<character> (65) is INSIDE to <bedroom> (67)\n<mouse> (413) is NEAR to <mousepad> (414)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<floor> (208) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <walllamp> (351)\n<mouse> (413) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <light> (411)\n<keyboard> (415) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <light> (411)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<floor> (326) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <floor> (208)\n<keyboard> (415) is NEAR to <computer> (417)\n<wall> (331) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <floor> (326)\n<cpuscreen> (416) is NEAR to <keyboard> (415)\n<light> (411) is NEAR to <keyboard> (415)\n<mouse> (413) is NEAR to <chair> (356)\n<walllamp> (351) is NEAR to <keyboard> (415)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <computer> (417)\n<computer> (417) is NEAR to <keyboard> (415)\n<wall> (213) is NEAR to <keyboard> (415)\n<floor> (325) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <floor> (325)\n<floor> (326) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (331)\n<floor> (325) is NEAR to <keyboard> (415)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<mousepad> (414) is NEAR to <keyboard> (415)\n<powersocket> (412) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <wall> (213)\n<wall> (331) is NEAR to <keyboard> (415)\n<wall> (330) is NEAR to <keyboard> (415)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<light> (411) is NEAR to <mouse> (413)\n<keyboard> (415) is NEAR to <chair> (356)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "719_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\ndining_room, id: 201, properties: []\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "757_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nkeyboard, id: 168, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\ncomputer, id: 170, properties: ['LOOKABLE', 'HAS_SWITCH']\nmouse, id: 166, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "787_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "795_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 168, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncomputer, id: 170, properties: ['LOOKABLE', 'HAS_SWITCH']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "819_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\ndining_room, id: 201, properties: []\nhair, id: 2004, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "874_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "910_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "91_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nfloor, id: 208, properties: ['SURFACES']\nwall, id: 213, properties: []\ndoorjamb, id: 346, properties: []\npowersocket, id: 412, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<mouse> (413) is NEAR to <wall> (213)\n<character> (65) is INSIDE to <dining_room> (201)\n<mouse> (413) is NEAR to <wall> (331)\n<mousepad> (414) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (326)\n<mouse> (413) is NEAR to <powersocket> (412)\n<mouse> (413) is NEAR to <wall> (330)\n<wall> (213) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <mousepad> (414)\n<mouse> (413) is NEAR to <cpuscreen> (416)\n<keyboard> (415) is NEAR to <mouse> (413)\n<chair> (356) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <floor> (325)\n<mouse> (413) is NEAR to <keyboard> (415)\n<floor> (208) is NEAR to <mouse> (413)\n<doorjamb> (346) is NEAR to <mouse> (413)\n<desk> (357) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <doorjamb> (346)\n<mouse> (413) is NEAR to <floor> (208)\n<wall> (331) is NEAR to <mouse> (413)\n<computer> (417) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <chair> (356)\n<mouse> (413) is NEAR to <computer> (417)\n<floor> (325) is NEAR to <mouse> (413)\n<floor> (326) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <desk> (357)\n<wall> (330) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <desk> (357)\n<powersocket> (412) is NEAR to <mouse> (413)\n<cpuscreen> (416) is NEAR to <mouse> (413)\n<mouse> (413) is ON to <mousepad> (414)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "93_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\ncheck, id: 1000, properties: ['READABLE', 'HAS_PAPER', 'MOVABLE', 'GRABBABLE']\nhomework, id: 1001, properties: ['READABLE', 'HAS_PAPER', 'MOVABLE', 'GRABBABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhair, id: 2005, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "962_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbutton, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncomputer, states: ['OFF', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncomputer is ON\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1027_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nbed, id: 105, properties: ['SITTABLE', 'SURFACES', 'LIEABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "181_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nbathroom, id: 1, properties: []\nbed, id: 105, properties: ['SITTABLE', 'SURFACES', 'LIEABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "244_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nbed, id: 105, properties: ['SITTABLE', 'SURFACES', 'LIEABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "269_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nbathroom, id: 1, properties: []\nbed, id: 105, properties: ['SITTABLE', 'SURFACES', 'LIEABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "509_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nclothes_pants, id: 1000, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE', 'HANGABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nclothes_shirt, id: 1002, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE', 'HANGABLE']\nclothes_pants, id: 1003, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE', 'HANGABLE']\nclothes_shirt, id: 1001, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE', 'HANGABLE']\nbed, id: 105, properties: ['SITTABLE', 'SURFACES', 'LIEABLE']\nsheets, id: 1004, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['ON', 'CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n<clothes_pants> (1003) is NEAR to <clothes_pants> (1000)\n<clothes_shirt> (1002) is NEAR to <clothes_pants> (1000)\n<clothes_pants> (1000) is ON to <character> (65)\n<clothes_shirt> (1001) is ON to <character> (65)\n<clothes_pants> (1000) is NEAR to <clothes_shirt> (1002)\n<clothes_pants> (1000) is NEAR to <clothes_pants> (1003)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "875_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nfloor, id: 70, properties: ['SURFACES']\nfloor, id: 71, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nfloor, id: 207, properties: ['SURFACES']\nwall, id: 80, properties: []\nwall, id: 82, properties: []\nwindow, id: 86, properties: []\ntablelamp, id: 97, properties: ['HAS_SWITCH']\ntablelamp, id: 98, properties: ['HAS_SWITCH']\nnightstand, id: 100, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\nnightstand, id: 102, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\nbed, id: 105, properties: ['SITTABLE', 'SURFACES', 'LIEABLE']\nmat, id: 173, properties: ['LIEABLE', 'SURFACES', 'SITTABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 176, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ncurtain, id: 179, properties: ['COVER_OBJECT', 'CAN_OPEN', 'MOVABLE']\ncurtain, id: 180, properties: ['COVER_OBJECT', 'CAN_OPEN', 'MOVABLE']\ncurtain, id: 181, properties: ['COVER_OBJECT', 'CAN_OPEN', 'MOVABLE']\npillow, id: 182, properties: ['MOVABLE', 'GRABBABLE']\npillow, id: 183, properties: ['MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<pillow> (182) is NEAR to <tablelamp> (97)\n<nightstand> (100) is NEAR to <pillow> (182)\n<character> (65) is INSIDE to <dining_room> (201)\n<wall> (82) is NEAR to <pillow> (182)\n<floor> (71) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <nightstand> (102)\n<pillow> (182) is FACING to <drawing> (176)\n<floor> (207) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <floor> (207)\n<window> (86) is NEAR to <pillow> (182)\n<tablelamp> (97) is NEAR to <pillow> (182)\n<curtain> (181) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <mat> (173)\n<nightstand> (102) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <curtain> (180)\n<pillow> (182) is NEAR to <floor> (71)\n<pillow> (182) is NEAR to <nightstand> (100)\n<pillow> (183) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <wall> (80)\n<curtain> (180) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <window> (86)\n<tablelamp> (98) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <wall> (82)\n<curtain> (179) is NEAR to <pillow> (182)\n<mat> (173) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <curtain> (181)\n<pillow> (182) is NEAR to <tablelamp> (98)\n<floor> (70) is NEAR to <pillow> (182)\n<pillow> (182) is ON to <floor> (207)\n<pillow> (182) is NEAR to <floor> (70)\n<pillow> (182) is NEAR to <curtain> (179)\n<wall> (80) is NEAR to <pillow> (182)\n<pillow> (182) is NEAR to <pillow> (183)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to bed\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nSLEEP\nSLEEP\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "102_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "154_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\ntowel, id: 1002, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nhands_both, id: 1003, properties: ['BODY_PART']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n<sink> (42) is NEAR to <towel> (1002)\n<towel> (1002) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <soap> (1000)\n<soap> (1000) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "176_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "214_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "258_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\nfaucet, id: 232, properties: ['HAS_SWITCH']\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\n\nEdges:\n<sink> (231) is NEAR to <soap> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<soap> (1000) is NEAR to <sink> (231)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "499_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['POURABLE', 'DRINKABLE']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\npaper_towel, id: 1003, properties: ['HANGABLE', 'HAS_PAPER', 'CUTTABLE', 'COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1002, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (42) is NEAR to <soap> (1001)\n<paper_towel> (1003) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <paper_towel> (1003)\n<character> (65) is INSIDE to <home_office> (319)\n<soap> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "517_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<soap> (1000) is NEAR to <sink> (42)\n<character> (65) is INSIDE to <home_office> (319)\n<soap> (1000) is ON to <sink> (42)\n<sink> (42) is NEAR to <soap> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "549_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nhands_both, id: 1000, properties: ['BODY_PART']\ncharacter, id: 65, properties: []\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "562_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['POURABLE', 'DRINKABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n<faucet> (43) is NEAR to <water> (1000)\n<water> (1000) is NEAR to <faucet> (43)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nwater is INSIDE to hands_both\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "580_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\ntowel, id: 1002, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (42) is NEAR to <towel> (1002)\n<sink> (42) is NEAR to <soap> (1001)\n<character> (65) is INSIDE to <bedroom> (67)\n<towel> (1002) is NEAR to <sink> (42)\n<soap> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "657_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\ndining_room, id: 201, properties: []\ntowel, id: 1002, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (43) is NEAR to <towel> (1002)\n<character> (65) is INSIDE to <dining_room> (201)\n<soap> (1001) is NEAR to <faucet> (43)\n<faucet> (43) is NEAR to <soap> (1001)\n<towel> (1002) is NEAR to <faucet> (43)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "660_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "672_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\ndining_room, id: 201, properties: []\ntowel, id: 1002, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (43) is NEAR to <towel> (1002)\n<character> (65) is INSIDE to <dining_room> (201)\n<soap> (1001) is NEAR to <faucet> (43)\n<faucet> (43) is NEAR to <soap> (1001)\n<towel> (1002) is NEAR to <faucet> (43)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "710_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['POURABLE', 'DRINKABLE']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nhands_both, id: 1002, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n<soap> (1001) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <soap> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "741_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nfaucet, id: 43, properties: ['HAS_SWITCH']\nhands_both, id: 1001, properties: ['BODY_PART']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (43) is NEAR to <soap> (1000)\n<soap> (1000) is NEAR to <faucet> (43)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "750_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\ntowel, id: 1003, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1002, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (42) is NEAR to <water> (1001)\n<character> (65) is INSIDE to <bedroom> (67)\n<towel> (1003) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <towel> (1003)\n<water> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nwater is INSIDE to hands_both\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "805_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\ntowel, id: 1001, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n<sink> (42) is NEAR to <towel> (1001)\n<sink> (42) is NEAR to <soap> (1000)\n<soap> (1000) is NEAR to <sink> (42)\n<towel> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "80_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nfaucet, id: 43, properties: ['HAS_SWITCH']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "813_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['POURABLE', 'DRINKABLE']\nhands_both, id: 1001, properties: ['BODY_PART']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "928_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhands_both, id: 1000, properties: ['BODY_PART']\nbathroom_counter, id: 41, properties: ['SURFACES']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "995_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nsoap, id: 1000, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nfaucet, id: 43, properties: ['HAS_SWITCH']\nhands_both, id: 1001, properties: ['BODY_PART']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nRINSE or WASH\nRINSE|WASH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1035_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "113_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "12_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "137_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "203_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nhair, id: 2014, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "220_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "242_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "279_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "287_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "292_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhair, id: 2006, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "297_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "381_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "388_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "38_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nface, id: 1001, properties: ['BODY_PART']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "429_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "437_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhair, id: 2013, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "451_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "469_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "479_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "502_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "612_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "856_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncat, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to cat\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nTOUCH\nTOUCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "60_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 325, properties: ['SURFACES']\nfloor, id: 326, properties: ['SURFACES']\ndining_room, id: 201, properties: []\nwall, id: 330, properties: []\nwall, id: 331, properties: []\nwall, id: 213, properties: []\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nwalllamp, id: 351, properties: []\ncpuscreen, id: 416, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nlaptop, id: 1000, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nlaptop, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n<keyboard> (415) is ON to <desk> (357)\n<keyboard> (415) is NEAR to <cpuscreen> (416)\n<laptop> (1000) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (330)\n<keyboard> (415) is NEAR to <mouse> (413)\n<mouse> (413) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <walllamp> (351)\n<keyboard> (415) is NEAR to <mousepad> (414)\n<floor> (326) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <computer> (417)\n<keyboard> (415) is NEAR to <floor> (326)\n<cpuscreen> (416) is NEAR to <keyboard> (415)\n<walllamp> (351) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <desk> (357)\n<computer> (417) is NEAR to <keyboard> (415)\n<wall> (213) is NEAR to <keyboard> (415)\n<chair> (356) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <floor> (325)\n<keyboard> (415) is NEAR to <wall> (331)\n<floor> (325) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <laptop> (1000)\n<mousepad> (414) is NEAR to <keyboard> (415)\n<desk> (357) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <wall> (213)\n<wall> (331) is NEAR to <keyboard> (415)\n<wall> (330) is NEAR to <keyboard> (415)\n<keyboard> (415) is NEAR to <chair> (356)\n-----------------\n\n\nNode goals are:\nlaptop is ON\nlaptop is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to laptop\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1070_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntoothbrush_holder, id: 1000, properties: ['CONTAINERS', 'MOVABLE', 'GRABBABLE']\ntoothbrush, id: 1001, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE']\ntooth_paste, id: 1002, properties: ['CAN_OPEN', 'POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\nteeth, id: 1003, properties: ['MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<toothbrush> (1001) is ON to <toothbrush_holder> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<toothbrush> (1001) is NEAR to <toothbrush_holder> (1000)\n<toothbrush_holder> (1000) is NEAR to <toothbrush> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "313_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntooth_paste, id: 1000, properties: ['CAN_OPEN', 'POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\ntowel, id: 1003, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\ntoothbrush, id: 1001, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE']\nteeth, id: 1002, properties: ['MOVABLE', 'GRABBABLE']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n<sink> (42) is NEAR to <toothbrush> (1001)\n<towel> (1003) is NEAR to <sink> (42)\n<sink> (42) is NEAR to <tooth_paste> (1000)\n<sink> (42) is NEAR to <towel> (1003)\n<tooth_paste> (1000) is NEAR to <sink> (42)\n<tooth_paste> (1000) is ON to <sink> (42)\n<toothbrush> (1001) is NEAR to <sink> (42)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "689_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\ntoothbrush_holder, id: 1000, properties: ['CONTAINERS', 'MOVABLE', 'GRABBABLE']\ntooth_paste, id: 1001, properties: ['CAN_OPEN', 'POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\ntoothbrush, id: 1002, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<tooth_paste> (1001) is ON to <toothbrush_holder> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<toothbrush> (1002) is NEAR to <toothbrush_holder> (1000)\n<toothbrush_holder> (1000) is NEAR to <toothbrush> (1002)\n<tooth_paste> (1001) is NEAR to <toothbrush_holder> (1000)\n<toothbrush_holder> (1000) is NEAR to <tooth_paste> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "718_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\ntooth_paste, id: 1000, properties: ['CAN_OPEN', 'POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\ntoothbrush, id: 1001, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<toothbrush> (1001) is NEAR to <tooth_paste> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n<tooth_paste> (1000) is NEAR to <toothbrush> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to toothbrush\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1049_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndvd_player, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ndvd_player, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ndvd_player is CLOSED\ndvd_player is ON\ndvd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "113_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncd_player, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "161_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "173_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncd_player, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nheadset, id: 1001, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['CLEAN', 'OFF', 'PLUGGED_OUT', 'CLOSED'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n<headset> (1001) is NEAR to <cd_player> (1000)\n<cd_player> (1000) is NEAR to <headset> (1001)\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "23_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "263_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "305_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nmouse, id: 166, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 167, properties: ['SURFACES', 'MOVABLE']\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nkeyboard, id: 168, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndesk, id: 104, properties: ['SURFACES', 'MOVABLE']\ncpuscreen, id: 171, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "363_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nmusic_stand, id: 1000, properties: ['CONTAINERS', 'SURFACES', 'MOVABLE', 'CAN_OPEN']\ndvd_player, id: 1001, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nremote_control, id: 1002, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ndvd_player, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<music_stand> (1000) is NEAR to <remote_control> (1002)\n<character> (65) is INSIDE to <bedroom> (67)\n<remote_control> (1002) is NEAR to <music_stand> (1000)\n-----------------\n\n\nNode goals are:\ndvd_player is CLOSED\ndvd_player is ON\ndvd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "385_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncd_player, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "403_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhair, id: 2004, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "415_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nheadset, id: 1000, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nheadset is ON to character\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "462_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nheadset, id: 1001, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, states: [], properties:[]\n\nEdges:\n<headset> (1001) is NEAR to <stereo> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<stereo> (1000) is NEAR to <headset> (1001)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "463_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "503_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncd_player, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1001, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "59_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nheadset, id: 1001, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<headset> (1001) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n<phone> (1000) is NEAR to <headset> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nheadset is ON to character\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "737_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "773_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "910_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\nstereo is CLOSED\nstereo is ON\nstereo is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "953_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nmusic_stand, id: 1000, properties: ['CONTAINERS', 'SURFACES', 'MOVABLE', 'CAN_OPEN']\ncd_player, id: 1001, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncd_player, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncd_player is CLOSED\ncd_player is ON\ncd_player is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1057_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nhair, id: 2001, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "117_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<remote_control> (1000) is NEAR to <television> (410)\n<character> (65) is INSIDE to <bathroom> (1)\n<couch> (352) is NEAR to <remote_control> (1000)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "134_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<remote_control> (1000) is NEAR to <television> (410)\n<character> (65) is INSIDE to <bathroom> (1)\n<couch> (352) is NEAR to <remote_control> (1000)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "170_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "197_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\nelectrical_outlet, id: 1001, properties: ['HAS_SWITCH']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nelectrical_outlet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<chair> (356) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n<electrical_outlet> (1001) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <electrical_outlet> (1001)\n<remote_control> (1000) is NEAR to <chair> (356)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "21_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ntable, id: 355, properties: ['SURFACES', 'MOVABLE']\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "225_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncoffee_table, id: 1000, properties: ['SURFACES', 'MOVABLE']\nremote_control, id: 1001, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<remote_control> (1001) is ON to <coffee_table> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<remote_control> (1001) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <remote_control> (1001)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "259_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "307_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "329_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <television> (410)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "342_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "377_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "383_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "411_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "454_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "459_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "548_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ntelevision, id: 248, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "595_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncoffee_table, id: 1001, properties: ['SURFACES', 'MOVABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "684_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<remote_control> (1000) is NEAR to <television> (410)\n<television> (410) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "74_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<remote_control> (1000) is NEAR to <television> (410)\n<character> (65) is INSIDE to <bathroom> (1)\n<couch> (352) is NEAR to <remote_control> (1000)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "806_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "98_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<television> (410) is NEAR to <remote_control> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<remote_control> (1000) is NEAR to <couch> (352)\n<remote_control> (1000) is NEAR to <television> (410)\n<couch> (352) is NEAR to <remote_control> (1000)\n-----------------\n\n\nNode goals are:\ntelevision is ON\ntelevision is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\ncharacter is FACING to television\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nLOOKAT or WATCH\nLOOKAT|WATCH\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1064_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "156_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\nfaucet, id: 232, properties: ['HAS_SWITCH']\ncup, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (232) is NEAR to <cup> (1000)\n<sink> (231) is NEAR to <cup> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<cup> (1000) is NEAR to <sink> (231)\n<cup> (1000) is NEAR to <faucet> (232)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "171_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\ncup, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\ndining_room, id: 201, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<cup> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <cup> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<sink> (231) is NEAR to <cup> (1000)\n<cup> (1000) is INSIDE to <cupboard> (229)\n<cup> (1000) is NEAR to <sink> (231)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "175_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfaucet, id: 232, properties: ['HAS_SWITCH']\ncharacter, id: 65, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\ncup, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (231) is NEAR to <cup> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<cup> (1000) is NEAR to <sink> (231)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "181_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<freezer> (289) is NEAR to <water_glass> (1000)\n<water> (1001) is NEAR to <freezer> (289)\n<freezer> (289) is NEAR to <water> (1001)\n<water> (1001) is INSIDE to <freezer> (289)\n<water_glass> (1000) is NEAR to <freezer> (289)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "26_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\ncup, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhair, id: 2009, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (232) is NEAR to <cup> (1000)\n<cup> (1000) is NEAR to <faucet> (232)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "286_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncupboard, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<water_glass> (1000) is NEAR to <cupboard> (229)\n<water> (1001) is INSIDE to <freezer> (289)\n<cupboard> (229) is NEAR to <water_glass> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<water_glass> (1000) is INSIDE to <cupboard> (229)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "291_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater, id: 1000, properties: ['POURABLE', 'DRINKABLE']\nwater_glass, id: 1001, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<water_glass> (1001) is NEAR to <water> (1000)\n<water_glass> (1001) is INSIDE to <dining_room> (201)\n<character> (65) is INSIDE to <bathroom> (1)\n<water> (1000) is NEAR to <water_glass> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "317_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\ncup, id: 1001, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\n-----------------\n\n\nThe current environment state is\nNodes:\nkitchen_cabinet, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'SURFACES', 'CAN_OPEN']\n\nEdges:\n<cup> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <cup> (1001)\n<character> (65) is INSIDE to <bathroom> (1)\n<cup> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<cup> (1001) is NEAR to <kitchen_cabinet> (1000)\n<kitchen_cabinet> (1000) is NEAR to <cup> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "488_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\ncup, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n<water> (1001) is ON to <sink> (231)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "510_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nwater, id: 1000, properties: ['POURABLE', 'DRINKABLE']\ndining_room, id: 201, properties: []\ndrinking_glass, id: 1001, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n<drinking_glass> (1001) is NEAR to <water> (1000)\n<water> (1000) is NEAR to <drinking_glass> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to drinking_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "528_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\ndrinking_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<freezer> (289) is NEAR to <drinking_glass> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<drinking_glass> (1000) is INSIDE to <freezer> (289)\n<drinking_glass> (1000) is NEAR to <freezer> (289)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to drinking_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "532_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\ndrinking_glass, id: 1001, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1002, properties: ['POURABLE', 'DRINKABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<drinking_glass> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <drinking_glass> (1001)\n<character> (65) is INSIDE to <bathroom> (1)\n<drinking_glass> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<drinking_glass> (1001) is NEAR to <kitchen_cabinet> (1000)\n<kitchen_cabinet> (1000) is NEAR to <drinking_glass> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to drinking_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "589_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncup, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "600_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<freezer> (289) is NEAR to <water_glass> (1000)\n<water_glass> (1000) is INSIDE to <freezer> (289)\n<water_glass> (1000) is NEAR to <freezer> (289)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "662_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "787_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\nfaucet, id: 232, properties: ['HAS_SWITCH']\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<faucet> (232) is NEAR to <water_glass> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<sink> (231) is NEAR to <water_glass> (1000)\n<water> (1001) is NEAR to <water_glass> (1000)\n<water_glass> (1000) is NEAR to <sink> (231)\n<water_glass> (1000) is NEAR to <water> (1001)\n<water_glass> (1000) is NEAR to <faucet> (232)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "788_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\nfaucet, id: 232, properties: ['HAS_SWITCH']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\ndrinking_glass, id: 1001, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1002, properties: ['POURABLE', 'DRINKABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\nkitchen_cabinet, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'SURFACES', 'CAN_OPEN']\n\nEdges:\n<drinking_glass> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <drinking_glass> (1001)\n<character> (65) is INSIDE to <bathroom> (1)\n<drinking_glass> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<drinking_glass> (1001) is NEAR to <kitchen_cabinet> (1000)\n<kitchen_cabinet> (1000) is NEAR to <drinking_glass> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to drinking_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "814_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<water> (1001) is INSIDE to <cupboard> (229)\n<water_glass> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <water_glass> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<water_glass> (1000) is INSIDE to <cupboard> (229)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "850_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\nwater_glass, id: 1001, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\nkitchen_cabinet, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'SURFACES', 'CAN_OPEN']\n\nEdges:\n<water_glass> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<water_glass> (1001) is NEAR to <kitchen_cabinet> (1000)\n<kitchen_cabinet> (1000) is NEAR to <water_glass> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "861_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\ncup, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\ndining_room, id: 201, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sink> (231) is NEAR to <cup> (1000)\n<cup> (1000) is ON to <sink> (231)\n<character> (65) is INSIDE to <bedroom> (67)\n<cup> (1000) is NEAR to <sink> (231)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to cup\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "878_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<water> (1001) is INSIDE to <cupboard> (229)\n<water_glass> (1000) is NEAR to <cupboard> (229)\n<cupboard> (229) is NEAR to <water_glass> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<water_glass> (1000) is INSIDE to <cupboard> (229)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to water_glass\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nDRINK\nDRINK\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1073_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<light> (411) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <light> (411)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1088_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\nfiling_cabinet, id: 399, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<novel> (1000) is ON to <filing_cabinet> (399)\n<novel> (1000) is NEAR to <filing_cabinet> (399)\n<filing_cabinet> (399) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "15_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\naddress_book, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to address_book\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "163_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<chair> (356) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<novel> (1000) is NEAR to <chair> (356)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "16_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ncoffee_table, id: 1001, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<novel> (1000) is NEAR to <coffee_table> (1001)\n<coffee_table> (1001) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n<novel> (1000) is ON to <coffee_table> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "192_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<couch> (352) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <couch> (352)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "208_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhair, id: 2006, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\nnovel, id: 1001, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE']\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n<novel> (1001) is NEAR to <floor_lamp> (1000)\n<floor_lamp> (1000) is NEAR to <novel> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "221_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nnovel, id: 1001, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "241_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "484_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncomputer, id: 417, properties: ['LOOKABLE', 'HAS_SWITCH']\nbedroom, id: 67, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n<chair> (356) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <chair> (356)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "504_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "508_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "544_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "57_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<couch> (352) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "617_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntablelamp, id: 97, properties: ['HAS_SWITCH']\nbedroom, id: 67, properties: []\nnightstand, id: 100, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nbed, id: 105, properties: ['SITTABLE', 'SURFACES', 'LIEABLE']\ndrawing, id: 176, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nnightstand, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'SURFACES', 'CAN_OPEN']\n\nEdges:\n<nightstand> (100) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<novel> (1000) is INSIDE to <nightstand> (100)\n<novel> (1000) is NEAR to <nightstand> (100)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "628_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<couch> (352) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "688_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nspectacles, id: 1001, properties: ['CLOTHES', 'MOVABLE', 'GRABBABLE']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<couch> (352) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<light> (411) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <couch> (352)\n<spectacles> (1001) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <light> (411)\n<novel> (1000) is NEAR to <spectacles> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "693_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nbedroom, id: 67, properties: []\nchair, id: 103, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<chair> (103) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<novel> (1000) is NEAR to <chair> (103)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "821_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<chair> (356) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<novel> (1000) is NEAR to <chair> (356)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "86_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nfiling_cabinet, id: 399, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<novel> (1000) is ON to <filing_cabinet> (399)\n<novel> (1000) is NEAR to <filing_cabinet> (399)\n<filing_cabinet> (399) is NEAR to <novel> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "896_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ncpuscreen, id: 416, properties: []\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nbookmark, id: 1001, properties: ['HAS_PAPER', 'MOVABLE', 'GRABBABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<novel> (1000) is NEAR to <desk> (357)\n<novel> (1000) is ON to <desk> (357)\n<desk> (357) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <couch> (352)\n<bookmark> (1001) is NEAR to <desk> (357)\n<desk> (357) is NEAR to <bookmark> (1001)\n<couch> (352) is NEAR to <novel> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_LH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "897_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntable, id: 355, properties: ['SURFACES', 'MOVABLE']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nnovel, id: 1000, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<light> (411) is NEAR to <novel> (1000)\n<novel> (1000) is NEAR to <light> (411)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to novel\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nREAD or LOOKAT\nREAD|LOOKAT\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "1083_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\noven, id: 295, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\npot, id: 1000, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE', 'CAN_OPEN']\nfood_vegetable, id: 1001, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nwater, id: 1002, properties: ['POURABLE', 'DRINKABLE']\ndining_room, id: 201, properties: []\npot, id: 1003, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE', 'CAN_OPEN']\n-----------------\n\n\nThe current environment state is\nNodes:\noven, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n<water> (1002) is NEAR to <oven> (295)\n<oven> (295) is NEAR to <water> (1002)\n-----------------\n\n\nNode goals are:\noven is CLOSED\noven is ON\noven is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\npot is ON to oven\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "392_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfreezer, id: 289, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\npot, id: 1001, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE', 'CAN_OPEN']\noven, id: 295, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\nfreezer, states: ['CLOSED', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\noven, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<pot> (1001) is INSIDE to <freezer> (289)\n<pot> (1001) is NEAR to <freezer> (289)\n<freezer> (289) is NEAR to <pot> (1001)\n-----------------\n\n\nNode goals are:\noven is CLOSED\noven is ON\noven is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\npot is ON to oven\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "755_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\noven, id: 295, properties: ['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\ndining_room, id: 201, properties: []\nwater, id: 1002, properties: ['POURABLE', 'DRINKABLE']\nsauce_pan, id: 1003, properties: ['SURFACES', 'CONTAINERS', 'RECIPIENT', 'MOVABLE', 'GRABBABLE']\npasta, id: 1001, properties: ['POURABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nkitchen_cabinet, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'SURFACES', 'CAN_OPEN']\noven, states: ['CLOSED', 'OFF', 'CLEAN', 'PLUGGED_IN'], properties:['CONTAINERS', 'HAS_SWITCH', 'CAN_OPEN', 'HAS_PLUG']\n\nEdges:\n<water> (1002) is INSIDE to <kitchen_cabinet> (1000)\n<kitchen_cabinet> (1000) is NEAR to <water> (1002)\n<sauce_pan> (1003) is NEAR to <kitchen_cabinet> (1000)\n<water> (1002) is NEAR to <kitchen_cabinet> (1000)\n<sauce_pan> (1003) is INSIDE to <kitchen_cabinet> (1000)\n<pasta> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<pasta> (1001) is NEAR to <kitchen_cabinet> (1000)\n<kitchen_cabinet> (1000) is NEAR to <sauce_pan> (1003)\n<kitchen_cabinet> (1000) is NEAR to <pasta> (1001)\n-----------------\n\n\nNode goals are:\noven is CLOSED\noven is ON\noven is PLUGGED_IN\n-----------------\n\n\nEdge goals are:\nsauce_pan is ON to oven\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "124_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhair, id: 2006, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "137_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "204_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ncoffee, id: 1000, properties: ['POURABLE', 'GRABBABLE', 'MOVABLE', 'DRINKABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<television> (410) is NEAR to <coffee> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<coffee> (1000) is NEAR to <couch> (352)\n<coffee> (1000) is NEAR to <television> (410)\n<couch> (352) is NEAR to <coffee> (1000)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "268_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "297_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 322, properties: ['SURFACES']\nbedroom, id: 67, properties: []\nfloor, id: 323, properties: ['SURFACES']\nwall, id: 329, properties: []\nwall, id: 333, properties: []\ndrawing, id: 400, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nmat, id: 401, properties: ['LIEABLE', 'SURFACES', 'SITTABLE', 'MOVABLE', 'GRABBABLE']\npillow, id: 405, properties: ['MOVABLE', 'GRABBABLE']\ncurtain, id: 409, properties: ['COVER_OBJECT', 'CAN_OPEN', 'MOVABLE']\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nwindow, id: 348, properties: []\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\nchair, id: 356, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nfloor_lamp, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nfloor_lamp, states: ['CLEAN', 'ON'], properties:['HAS_SWITCH', 'MOVABLE']\ncharacter, states: [], properties:[]\n\nEdges:\n<pillow> (405) is NEAR to <mat> (401)\n<window> (348) is NEAR to <pillow> (405)\n<wall> (329) is NEAR to <pillow> (405)\n<pillow> (405) is FACING to <television> (410)\n<pillow> (405) is FACING to <drawing> (400)\n<character> (65) is INSIDE to <bedroom> (67)\n<curtain> (409) is NEAR to <pillow> (405)\n<chair> (356) is NEAR to <pillow> (405)\n<pillow> (405) is NEAR to <window> (348)\n<pillow> (405) is NEAR to <floor> (323)\n<pillow> (405) is NEAR to <chair> (356)\n<wall> (333) is NEAR to <pillow> (405)\n<pillow> (405) is NEAR to <curtain> (409)\n<pillow> (405) is NEAR to <wall> (329)\n<floor> (323) is NEAR to <pillow> (405)\n<mat> (401) is NEAR to <pillow> (405)\n<floor> (322) is NEAR to <pillow> (405)\n<pillow> (405) is NEAR to <floor> (322)\n<pillow> (405) is NEAR to <wall> (333)\n<drawing> (400) is NEAR to <pillow> (405)\n<pillow> (405) is NEAR to <drawing> (400)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "299_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "300_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "321_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nwater_glass, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n<couch> (352) is NEAR to <water_glass> (1000)\n<water_glass> (1000) is NEAR to <couch> (352)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "332_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "379_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "387_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "390_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "3_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "416_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "438_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "442_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "447_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ncoffee_cup, id: 1000, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nnovel, id: 1001, properties: ['READABLE', 'CAN_OPEN', 'HAS_PAPER', 'CUTTABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n<coffee_cup> (1000) is NEAR to <couch> (352)\n<novel> (1001) is NEAR to <couch> (352)\n<couch> (352) is NEAR to <coffee_cup> (1000)\n<couch> (352) is NEAR to <novel> (1001)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "449_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nremote_control, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<couch> (352) is NEAR to <remote_control> (1000)\n<remote_control> (1000) is NEAR to <couch> (352)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "455_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "456_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "473_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nsheets, id: 1000, properties: ['COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "490_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "563_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "567_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nstereo, id: 1000, properties: ['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nlight, id: 411, properties: ['HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nstereo, states: ['CLEAN', 'OFF', 'PLUGGED_OUT', 'CLOSED'], properties:['SURFACES', 'CAN_OPEN', 'HAS_PLUG', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\ncharacter, states: [], properties:[]\nlight, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "570_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "674_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "6_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "742_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "762_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "793_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\ntelevision, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "798_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "932_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "941_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "96_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is SITTING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "976_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\ncharacter is LYING\n-----------------\n\n\nEdge goals are:\ncharacter is ON to couch\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "149_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ntable, id: 355, properties: ['SURFACES', 'MOVABLE']\nfood_food, id: 2003, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\n\nEdges:\n<phone> (1000) is NEAR to <table> (355)\n<phone> (1000) is ON to <table> (355)\n<table> (355) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "154_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nbutton, id: 1001, properties: ['MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<button> (1001) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n<phone> (1000) is NEAR to <button> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "180_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nhair, id: 2005, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: ['SITTING'], properties:[]\nphone, states: ['OFF', 'PLUGGED_OUT', 'CLEAN'], properties:['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "195_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\ntable, id: 355, properties: ['SURFACES', 'MOVABLE']\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ndining_room, id: 201, properties: []\ntelevision, id: 410, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncharacter, states: [], properties:[]\n\nEdges:\n<phone> (1000) is NEAR to <table> (355)\n<phone> (1000) is ON to <table> (355)\n<table> (355) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "211_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "241_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "264_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nshoe-shine_kit, id: 2002, properties: ['MOVABLE', 'GRABBABLE', 'CAN_OPEN']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<phone> (1000) is ON to <desk> (357)\n<desk> (357) is NEAR to <phone> (1000)\n<phone> (1000) is NEAR to <desk> (357)\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "265_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nbutton, id: 1001, properties: ['MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<button> (1001) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<phone> (1000) is NEAR to <button> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "287_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "352_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntable, id: 226, properties: ['SURFACES', 'MOVABLE']\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nmat, id: 236, properties: ['LIEABLE', 'SURFACES', 'SITTABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<phone> (247) is ON to <table> (226)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "360_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "388_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "431_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nphone, states: ['CLEAN', 'OFF', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "436_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "442_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "474_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "482_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nbathroom, id: 1, properties: []\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<character> (65) is INSIDE to <bathroom> (1)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "497_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nhair, id: 2005, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "553_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "601_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nbutton, id: 1000, properties: ['MOVABLE', 'GRABBABLE']\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 241, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 242, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 243, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ntelevision, id: 248, properties: ['LOOKABLE', 'HAS_SWITCH', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<phone> (247) is FACING to <television> (248)\n<phone> (247) is FACING to <drawing> (241)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is FACING to <drawing> (243)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<phone> (247) is NEAR to <drawing> (239)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<phone> (247) is FACING to <wall_clock> (249)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is FACING to <drawing> (242)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "70_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ndining_room, id: 201, properties: []\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nfork, id: 2008, properties: ['MOVABLE', 'GRABBABLE']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\nphone, states: ['CLEAN', 'PLUGGED_IN'], properties:['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n\nEdges:\n<phone> (1000) is ON to <desk> (357)\n<desk> (357) is NEAR to <phone> (1000)\n<phone> (1000) is NEAR to <desk> (357)\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "864_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nhair, id: 2004, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "963_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "974_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "976_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncpuscreen, id: 416, properties: []\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndesk, id: 357, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\nphone, id: 1000, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmouse, id: 413, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nmousepad, id: 414, properties: ['SURFACES', 'MOVABLE']\nkeyboard, id: 415, properties: ['MOVABLE', 'GRABBABLE', 'HAS_PLUG']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<desk> (357) is NEAR to <phone> (1000)\n<character> (65) is INSIDE to <bedroom> (67)\n<phone> (1000) is ON to <desk> (357)\n<phone> (1000) is NEAR to <desk> (357)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "99_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nfloor, id: 202, properties: ['SURFACES']\nfloor, id: 203, properties: ['SURFACES']\nfloor, id: 76, properties: ['SURFACES']\nfloor, id: 77, properties: ['SURFACES']\nfloor, id: 206, properties: ['SURFACES']\nwall, id: 209, properties: []\nwall, id: 211, properties: []\nwall, id: 84, properties: []\nwall, id: 85, properties: []\nceiling, id: 216, properties: []\nceiling, id: 217, properties: []\nceiling, id: 94, properties: []\ndoor, id: 222, properties: ['CAN_OPEN']\nceiling, id: 95, properties: []\ntable, id: 226, properties: ['SURFACES', 'MOVABLE']\ntrashcan, id: 99, properties: ['CONTAINERS', 'CAN_OPEN', 'MOVABLE']\ndoorjamb, id: 165, properties: []\nlight, id: 169, properties: ['HAS_SWITCH', 'HAS_PLUG']\nmat, id: 236, properties: ['LIEABLE', 'SURFACES', 'SITTABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 174, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 238, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 239, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\ndrawing, id: 240, properties: ['HAS_PAPER', 'CUTTABLE', 'LOOKABLE', 'MOVABLE', 'GRABBABLE']\nlight, id: 245, properties: ['HAS_SWITCH', 'HAS_PLUG']\npowersocket, id: 246, properties: []\nphone, id: 247, properties: ['HAS_SWITCH', 'MOVABLE', 'GRABBABLE', 'HAS_PLUG']\nwall_clock, id: 249, properties: ['HAS_PLUG', 'LOOKABLE', 'HAS_SWITCH', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<floor> (76) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (85)\n<phone> (247) is NEAR to <light> (169)\n<phone> (247) is NEAR to <table> (226)\n<drawing> (174) is NEAR to <phone> (247)\n<wall> (211) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <wall> (209)\n<phone> (247) is NEAR to <ceiling> (216)\n<phone> (247) is NEAR to <drawing> (174)\n<door> (222) is NEAR to <phone> (247)\n<wall> (85) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <ceiling> (94)\n<doorjamb> (165) is NEAR to <phone> (247)\n<ceiling> (216) is NEAR to <phone> (247)\n<floor> (203) is NEAR to <phone> (247)\n<light> (245) is NEAR to <phone> (247)\n<phone> (247) is ON to <table> (226)\n<wall> (209) is NEAR to <phone> (247)\n<ceiling> (94) is NEAR to <phone> (247)\n<drawing> (240) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <trashcan> (99)\n<drawing> (239) is NEAR to <phone> (247)\n<ceiling> (217) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (77)\n<phone> (247) is NEAR to <floor> (202)\n<phone> (247) is NEAR to <wall> (84)\n<phone> (247) is NEAR to <wall> (211)\n<table> (226) is NEAR to <phone> (247)\n<ceiling> (95) is NEAR to <phone> (247)\n<wall> (84) is NEAR to <phone> (247)\n<powersocket> (246) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <floor> (203)\n<phone> (247) is NEAR to <ceiling> (95)\n<floor> (77) is NEAR to <phone> (247)\n<floor> (206) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <drawing> (240)\n<floor> (202) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <door> (222)\n<phone> (247) is NEAR to <drawing> (238)\n<phone> (247) is NEAR to <wall_clock> (249)\n<phone> (247) is NEAR to <powersocket> (246)\n<phone> (247) is NEAR to <light> (245)\n<phone> (247) is NEAR to <ceiling> (217)\n<light> (169) is NEAR to <phone> (247)\n<wall_clock> (249) is NEAR to <phone> (247)\n<phone> (247) is NEAR to <doorjamb> (165)\n<phone> (247) is NEAR to <floor> (76)\n<phone> (247) is NEAR to <floor> (206)\n<phone> (247) is NEAR to <drawing> (239)\n<trashcan> (99) is NEAR to <phone> (247)\n<drawing> (238) is NEAR to <phone> (247)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is HOLDS_RH to phone\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "710_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ntable, id: 226, properties: ['SURFACES', 'MOVABLE']\nbathroom, id: 1, properties: []\nkitchen_cabinet, id: 1000, properties: ['CONTAINERS', 'SURFACES', 'CAN_OPEN']\ndining_room, id: 201, properties: []\nplate, id: 1001, properties: ['RECIPIENT', 'SURFACES', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nkitchen_cabinet, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'SURFACES', 'CAN_OPEN']\n\nEdges:\n<plate> (1001) is INSIDE to <kitchen_cabinet> (1000)\n<plate> (1001) is NEAR to <kitchen_cabinet> (1000)\n<character> (65) is INSIDE to <bathroom> (1)\n<kitchen_cabinet> (1000) is NEAR to <plate> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\nplate is ON to table\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "84_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncouch, id: 352, properties: ['SITTABLE', 'SURFACES', 'MOVABLE', 'LIEABLE']\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ntable, id: 355, properties: ['SURFACES', 'MOVABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "93_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nhair, id: 2000, properties: ['BODY_PART', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\ndining_room, id: 201, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "368_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncloth_napkin, id: 1000, properties: ['HAS_PAPER', 'CUTTABLE', 'COVER_OBJECT', 'MOVABLE', 'GRABBABLE']\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is INSIDE to dining_room\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "729_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nshower, id: 36, properties: []\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <dining_room> (201)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to shower\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "975_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nshower, id: 36, properties: []\nbathroom, id: 1, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bedroom> (67)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\ncharacter is CLOSE to shower\n-----------------\n\n\nAction goals are:\nThere is no action requirement.\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "231_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndining_room, id: 201, properties: []\nplate, id: 1000, properties: ['RECIPIENT', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1001, properties: ['POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\nwater, id: 1002, properties: ['POURABLE', 'DRINKABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<water> (1002) is NEAR to <plate> (1000)\n<plate> (1000) is NEAR to <dish_soap> (1001)\n<plate> (1000) is NEAR to <water> (1002)\n<dish_soap> (1001) is NEAR to <plate> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "31_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbedroom, id: 67, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\ndish_soap, id: 1000, properties: ['POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\nbowl, id: 1001, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE']\nsponge, id: 1002, properties: ['MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nplate, id: 1004, properties: ['RECIPIENT', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndishrack, id: 1003, properties: ['SURFACES', 'MOVABLE', 'GRABBABLE']\nfaucet, id: 232, properties: ['HAS_SWITCH']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<sponge> (1002) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <plate> (1004)\n<plate> (1004) is NEAR to <sink> (231)\n<character> (65) is INSIDE to <bedroom> (67)\n<bowl> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <bowl> (1001)\n<sink> (231) is NEAR to <dish_soap> (1000)\n<dish_soap> (1000) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <sponge> (1002)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "349_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndining_room, id: 201, properties: []\nfaucet, id: 232, properties: ['HAS_SWITCH']\ndish_soap, id: 1000, properties: ['POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\nplate, id: 1001, properties: ['RECIPIENT', 'SURFACES', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\n\nEdges:\n<faucet> (232) is NEAR to <dish_soap> (1000)\n<plate> (1001) is NEAR to <faucet> (232)\n<character> (65) is INSIDE to <bathroom> (1)\n<faucet> (232) is NEAR to <plate> (1001)\n<dish_soap> (1000) is NEAR to <faucet> (232)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "397_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\ndish_soap, id: 1000, properties: ['POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nplate, id: 1001, properties: ['RECIPIENT', 'SURFACES', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "429_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\ndining_room, id: 201, properties: []\ndish_soap, id: 1001, properties: ['POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<character> (65) is INSIDE to <bathroom> (1)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "553_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\nplate, id: 1000, properties: ['RECIPIENT', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nsoap, id: 1001, properties: ['CREAM', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nwater, id: 1002, properties: ['POURABLE', 'DRINKABLE']\nfood_kiwi, id: 2007, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nfood_food, id: 2009, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\ncupboard, states: ['CLEAN', 'CLOSED'], properties:['CONTAINERS', 'CAN_OPEN']\n\nEdges:\n<plate> (1000) is NEAR to <food_food> (2009)\n<plate> (1000) is NEAR to <food_kiwi> (2007)\n<food_kiwi> (2007) is NEAR to <plate> (1000)\n<soap> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <soap> (1001)\n<plate> (1000) is NEAR to <sink> (231)\n<plate> (1000) is ON to <sink> (231)\n<sink> (231) is NEAR to <plate> (1000)\n<food_food> (2009) is NEAR to <plate> (1000)\n<character> (65) is INSIDE to <home_office> (319)\n<food_food> (2009) is ON to <plate> (1000)\n<food_kiwi> (2007) is ON to <plate> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "594_2",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\ndish_soap, id: 1000, properties: ['POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\nplate, id: 1001, properties: ['RECIPIENT', 'SURFACES', 'MOVABLE', 'GRABBABLE']\nsink, id: 42, properties: ['RECIPIENT', 'CONTAINERS']\nbathroom_counter, id: 41, properties: ['SURFACES']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<dish_soap> (1000) is NEAR to <sink> (42)\n<dish_soap> (1000) is ON to <sink> (42)\n<sink> (42) is NEAR to <dish_soap> (1000)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "746_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\ndish_soap, id: 1000, properties: ['POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\nwater, id: 1001, properties: ['POURABLE', 'DRINKABLE']\nsponge, id: 1002, properties: ['MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\ndrinking_glass, id: 1003, properties: ['RECIPIENT', 'POURABLE', 'MOVABLE', 'GRABBABLE']\nhome_office, id: 319, properties: []\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<water> (1001) is NEAR to <sponge> (1002)\n<character> (65) is INSIDE to <home_office> (319)\n<sponge> (1002) is NEAR to <water> (1001)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "961_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\ncharacter, id: 65, properties: []\nbathroom, id: 1, properties: []\nkitchen_counter, id: 230, properties: ['SURFACES']\nsink, id: 231, properties: ['RECIPIENT', 'CONTAINERS']\nplate, id: 1000, properties: ['RECIPIENT', 'SURFACES', 'MOVABLE', 'GRABBABLE']\ndish_soap, id: 1001, properties: ['POURABLE', 'CREAM', 'MOVABLE', 'GRABBABLE']\ndishrack, id: 1002, properties: ['SURFACES', 'MOVABLE', 'GRABBABLE']\ndining_room, id: 201, properties: []\nfood_kiwi, id: 2003, properties: ['EATABLE', 'GRABBABLE', 'MOVABLE', 'CUTTABLE']\n-----------------\n\n\nThe current environment state is\nNodes:\n\nEdges:\n<food_kiwi> (2003) is ON to <plate> (1000)\n<food_kiwi> (2003) is NEAR to <plate> (1000)\n<dish_soap> (1001) is NEAR to <sink> (231)\n<sink> (231) is NEAR to <dish_soap> (1001)\n<character> (65) is INSIDE to <bathroom> (1)\n<sink> (231) is NEAR to <plate> (1000)\n<plate> (1000) is NEAR to <food_kiwi> (2003)\n<plate> (1000) is NEAR to <sink> (231)\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    },
    {
        "identifier": "988_1",
        "llm_prompt": "The task is to guide the robot to take actions from current state to fulfill some node goals, edge goals, and action goals. The input will be the related objects in the scene, nodes and edges in the current environment, and the desired node goals, edge goals, and action goals. The output should be action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy the goals. Additionally, the feedback section illustrates previously attempted action commands, and details the reason why they failed. Please learn from the feedback before your generation.\n\nData format:\nObjects in the scene indicates those objects involved in the action execution. It follows the format: <object_name> (object_id)\n\nNodes and edges in the current environment shows the nodes' names, states and properties, and edges in the environment. \nNodes follow the format: object_name, states:... , properties:...\nEdges follow the format: object_name A is ... to object_name B\n \nNode goals show the target object states in the ending environment. They follow the format: object_name is ... (some state)\n\nEdge goals show the target relationships of objects in the ending environment. They follow the format: object_name A is ... (some relationship) to object_name B.\n\nAction goals specify the necessary actions you need to include in your predicted action commands sequence, and the order they appear in action goals should also be the RELATIVE order they appear in your predicted action commands sequence if there are more than one line. Each line in action goals include one action or more than one actions concatenated by OR. You only need to include ONE of the actions concatenated by OR in the same line. For example, if the action goal is:\nThe following action(s) should be included:\nGRAB\nTYPE or TOUCH\nOPEN\n------------------------\nThen your predicted action commands sequence should include GRAB, either TYPE or TOUCH, and OPEN. Besides, GRAB should be executed earlier than TYPE or TOUCH, and TYPE or TOUCH should be executed earlier than OPEN.\nIf the action goal is:\nThe following action(s) should be included:\nThere is no action requirement.\nIt means there is no action you have to include in output, and you can use any action to achieve the node and edge goals. Warning: No action requirement does not mean empty output. You should always output some actions and their arguments.\n\n\nAction commands include action name and objects. The number of objects (required_number of parameters) for each action is fixed and is given below, either 0, 1, or 2. The output action commands should be in json format. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action, where [] is for 0 object, [object] is for 1 object, [object 1, object 2] is for 2 objects. The action commands order is represented by the order they appear in the json dictionary. The key value pair appearing first will be executed first, the key value pair appearing second will be executed second, so on and so forth.\n\nFor example, if you want to first FIND the sink and then PUTBACK cup to the sink, you should express it as {'FIND':['sink'], 'PUTBACK':['cup', 'sink']}\n\nThe object of action also needs to satisfied some properties preconditions. For example, SWITCHON's object number is 1. To switch on something, the object should 'HAS_SWITCH'. The rule is represented as SWITCHON = (\"Switch on\", 1, [['HAS_SWITCH']]). Another example is POUR. POUR's object number is 2. To pour sth A into sth B, A should be pourable and drinkable, and B should be RECIPIENT. The rule is represented as POUR = (\"Pour\", 2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]).\n\nAction Definitions Format:\nEach action is defined as a combination of:\nAction Name (String): A descriptive name for the action.\nRequired Number of Parameters (Integer): The count of parameters needed to perform the action.\nPreconditions for Each Object (List of Lists of Strings): Conditions that must be met for each object involved in the action.\n\nSupported Actions List:\nCLOSE: (1, [['CAN_OPEN']]) # Change state from OPEN to CLOSED\nDRINK: (1, [['DRINKABLE', 'RECIPIENT']]) # Consume a drinkable item\nFIND: (1, [[]]) # Locate and approach an item\nWALK: (1, [[]]) # Move towards something\nGRAB: (1, [['GRABBABLE']]) # Take hold of an item that can be grabbed\nLOOKAT: (1, [[]]) # Direct your gaze towards something\nOPEN: (1, [['CAN_OPEN']]) # Open an item that can be opened\nPOINTAT: (1, [[]]) # Point towards something\nPUTBACK: (2, [['GRABBABLE'], []]) # Place one object back onto or into another\nPUTIN: (2, [['GRABBABLE'], ['CAN_OPEN']]) # Insert one object into another\nRUN: (1, [[]]) # Run towards something\nSIT: (1, [['SITTABLE']]) # Sit on a suitable object\nSTANDUP: (0, []) # Stand up from a sitting or lying position\nSWITCHOFF: (1, [['HAS_SWITCH']]) # Turn off an item with a switch\nSWITCHON: (1, [['HAS_SWITCH']]) # Turn on an item with a switch\nTOUCH: (1, [[]]) # Physically touch something\nTURNTO: (1, [[]]) # Turn your body to face something\nWATCH: (1, [[]]) # Observe something attentively\nWIPE: (1, [[]]) # Clean or dry something by rubbing\nPUTON: (1, [['CLOTHES']]) # Dress oneself with an item of clothing\nPUTOFF: (1, [['CLOTHES']]) # Remove an item of clothing\nGREET: (1, [['PERSON']]) # Offer a greeting to a person\nDROP: (1, [[]]) # Let go of something so it falls\nREAD: (1, [['READABLE']]) # Read text from an object\nLIE: (1, [['LIEABLE']]) # Lay oneself down on an object\nPOUR: (2, [['POURABLE', 'DRINKABLE'], ['RECIPIENT']]) # Transfer a liquid from one container to another\nPUSH: (1, [['MOVABLE']]) # Exert force on something to move it away from you\nPULL: (1, [['MOVABLE']]) # Exert force on something to bring it towards you\nMOVE: (1, [['MOVABLE']]) # Change the location of an object\nWASH: (1, [[]]) # Clean something by immersing and agitating it in water\nRINSE: (1, [[]]) # Remove soap from something by applying water\nSCRUB: (1, [[]]) # Clean something by rubbing it hard with a brush\nSQUEEZE: (1, [['CLOTHES']]) # Compress clothes to extract liquid\nPLUGIN: (1, [['HAS_PLUG']]) # Connect an electrical device to a power source\nPLUGOUT: (1, [['HAS_PLUG']]) # Disconnect an electrical device from a power source\nCUT: (1, [['EATABLE', 'CUTABLE']]) # Cut some food\nEAT: (1, [['EATABLE']]) # Eat some food\nRELEASE: (1, [[]]) # Let go of something inside the current room\nTYPE: (1, [['HAS_SWITCH']]) # Type on a keyboard\n\nNotice: \n1. CLOSE action is opposed to OPEN action, CLOSE sth means changing the object's state from OPEN to CLOSE. \n\n2. You cannot [PUTIN] <character> <room name>. If you want robot INSIDE some room, please [WALK] <room name>.\n\n3. The subject of all these actions is <character>, that is, robot itself. Do not include <character> as object_name. NEVER EVER use character as any of the object_name, that is, the argument of actions.\n\n4. The action name should be upper case without white space. \n\n5. Importantly, if you want to apply ANY action on <object_name>, you should NEAR it. Therefore, you should apply WALK action as [WALK] <object_name> to first get near to the object before you apply any following actions, if you have no clue you are already NEAR <object_name>\n\n6. When output the objects, please only output object names but not their ids. Follow strictly the parameter number for each action. \n\n7. Output should not be empty! Always output some actions and their arguments.\n\nInput:\nThe relevant objects in the scene are:\nObjects in the scene:\nfaucet, id: 232, properties: ['HAS_SWITCH']\ncharacter, id: 65, properties: []\nbowl, id: 1001, properties: ['RECIPIENT', 'MOVABLE', 'GRABBABLE']\ncupboard, id: 229, properties: ['CONTAINERS', 'CAN_OPEN']\n-----------------\n\n\nThe current environment state is\nNodes:\nfaucet, states: ['OFF', 'CLEAN'], properties:['HAS_SWITCH']\n\nEdges:\n-----------------\n\n\nNode goals are:\n-----------------\n\n\nEdge goals are:\n-----------------\n\n\nAction goals are:\nThe following action(s) should be included:\nGRAB\nGRAB\nWASH or RINSE or SCRUB or WIPE\nWASH|RINSE|SCRUB|WIPE\n-----------------\n\n\nFeedback:\nThis is the first attempt.\n\n\nPlease output the list of action commands in json format so that after the robot executes the action commands sequentially, the ending environment would satisfy all the node goals, edge goals and action goals. The dictionary keys should be action names. The dictionary values should be a list containing the objects of the corresponding action. The feedback part illustrates the reason why previous outputs failed. Please pay attention to that. Only output the json of action commands in a dictionary with nothing else.\n\nOutput:"
    }
]